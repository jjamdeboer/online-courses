CONTAINERS ARE THE FUNDAMENTAL BUILDING BLOCKS OF DOCKER
DOCKER'S OLD STYLE WAS 'docker [COMMAND]', BUT NOWADAYS IT IS 'docker [MANAGEMENT COMMAND] [SUBCOMMAND]' (FOR EXAMPLE: 'docker run' VERSUS 'docker container run'); HOWEVER, DOCKER MAKES SURE TO BE BACKWARD COMPATIBLE, SO THE OLD STILL WORKS, BUT WILL NOT GET EXPANDED
LOCAL: CLIENT, 'REMOTE': ENGINE

THERE IS A DIFFERENCE BETWEEN AN IMAGE AND A CONTAINER: THE IMAGE IS A SPECIFIC SET OF PROGRAMS, THE CONTAINER IS A RUNNING INSTANCE OF THAT IMAGE AS A PROCESS; THEREFORE, THERE CAN BE MANY CONTAINERS BASED ON THE SAME IMAGE
HERE, THE IMAGE WILL BE THE OPEN SOURCE WEB SERVER NGINX (ENGINE X)
DOCKER'S DEFAULT REGISTRY/REPOSITORY FOR IMAGES IS THE DOCKER HUB, BUT OTHER CAN BE USED AS WELL
IF THE RESPECTIVE IMAGE IS NOT AVAILABLE LOCALLY, THE DEFAULT IS TO LOOK AT THE DOCKER HUB AND PULL THAT IMAGE BEFORE RUNNING THE CONTAINER
TO RUN A CONTAINER BASED ON AN IMAGE: 'docker container run [OPTIONS]' (FOR EXAMPLE 'docker container run --publish 8080:80 --detach nginx', WHICH RUNS AN NGINX CONTAINER, OPENING PORT 8080 ON THE HOST IP AND ROUTING ALL TRAFIC TO THE CONTAINER IP AT PORT 80 IN THE BACKGROUND, SINCE IT IS DETACHED)
TO LIST ALL RUNNING CONTAINER: 'docker container ls', OR, TO SEE ALSO THE STOPPED CONTAINERS: 'docker container ls -a'
TO STOP A CONTAINER: 'docker container stop [CONTAINER ID]'
THE COMMAND 'run' ALWAYS STARTS A NEW CONTAINER, TO START UP AN OLDER CONTAINER THAT WAS STOPPED PREVIOUSLY, USE: 'docker container start [CONTAINER ID]'
TO SEE A LIST OF ALL THE LOGS FOR A CONTAINER THAT IS RUNNING IN THE BACKGROUND (SINCE IN THE FOREGROUND LOGS ARE SIMPLY DISPLAYED IN THE TERMINAL): 'docker container logs [CONTAINER NAME OR ID]'
TO REALLY REMOVE CONTAINERS: 'docker container rm [WILDCARD, CONTAINER NAMES OR ID'S]'; PROCESSES/CONTAINERS THAT ARE STILL RUNNING CANNOT BE REMOVES

WHAT HAPPENS WHEN DOCKER RUNS A CONTAINER IS
WHEN DOCKER RUNS A CONTAINER IT LOOKS FOR AN IMAGE LOCALLY, THEN SWITCHES TO THE DOCKER HUB IF IT IS UNABLE TO FIND IT, IN CASE IT FINDS IT THERE, IT DOWNLOADS AND STORES THE LATEST VERSION, THEN STARTS A CONTAINER BASED ON THE IMAGE (PROVIDING A VIRTUAL DOCKER NETWORK TO THE IMAGE, SO NOT COPYING THE IMAGE, BUT ADDING AN ACTIVE LAYER TO IT), IT CAN OPEN UN A PORT IN THE HOST (LOCAL COMPUTER) AND ROUTES ALL TRAFIC TO THE DOCKER CONTAINER USING A PORT THERE AS WELL, THE IMAGE WILL START WITH EXECUTING THE COMMANDS SPECIFIED IN THE IMAGE
SINCE EVERYTHING IS CUSTOMIZABLE, A MORE SPECIFIC COMMAND COULD BE: 'docker container run --publish 8888:80 --name DURK -d nginx:1.11 nginx -T', WHERE THE SECOND 'nginx' IS THE COMMAND TO START WITH IN THE CONTAINER

CONTAINERS ARE NOT THE SAME AS VIRTUAL MACHINES: VIRTUAL MACHINES REALLY TAKE UP A PARTITIION ON YOUR DISK, CONTAINERS ARE PROCESSES THAT ACCESS THE AVAILABLE RESOURCES AND STOP WHEN THE PROCESS STOPS

TO SEE DETAILS ON THE CONTAINER, SEVERAL COMMANDS CAN BE USED: 'docker container top [CONTAINER NAME OR ID]' (LISTING THE PROCESSES RUN IN/BY THE CONTAINER), 'docker container inspect [CONTAINER NAME OR ID]' (DETAILS OF CONFIGURATION OF THE CONTAINER), 'docker container stats' (GIVING STATISTICS ON ALL CONTAINERS)
TO INTERACT WITH CONTAINERS, NO SSH IS NEEDED: 'docker container run [OPTIONS] -it [IMAGE TO BE USED]' STARTS A CONTAINER INTERACTIVELY AND 'docker container exec [NAME OR ID CONTAINER] [COMMAND TO BE EXECUTED] -it' EXECUTES A COMMAND ON A CONTAINER INTERACTIVELY
CONTAINERS ONLY RUN AS LONG AS THE COMMAND THAT STARTED THE CONTAINER RUNS (SO WHEN THAT PROCESS IS TERMINATED, THE CONTAINER STOPS)
LINUX IMAGES ARE VERY MINIMAL COMPARED TO LINUX ISO'S USED FOR INSTALLING LINUX ON A (VIRTUAL) MACHINE
THE IMPORTANT DIFFERENCE BETWEEN AN IMAGE AND A CONTAINER IS: EVERY CHANGE MADE BY THE CONTAINER WHEN IT RUNS IS NOT INCLUDED IN THE IMAGE, BUT THE REVERSE IS NOT TRUE

DOCKER HAS THE CONCEPT OF BATTERIES INCLUDED, BUT REMOVABLE, WHICH MEANS THAT EVERYTHING WORKS OUT OF THE BOX, BUT IS CUSTOMIZABLE
TO CHECK WHICH PORTS ARE OPEN/OCCUPIED: 'docker container port [NAME OR ID OF CONTAINER]'
DOCKER NETWORKS ARE ALSO CALLED DNS
EACH CONTAINER CAN BE CONNECTED TO A PRIVATE VIRTUAL NETWORK (DEFAULT IS CALLED 'BRIDGE') AND THIS VIRTUAL NETWORK ROUTES THROUGH THE HOST (NAT) FIREWALL, A CONTAINER DOES NOT NEED TO BE CONNECTED TO A VIRTUAL NETWORK
ALL CONTAINERS ON A VIRTUAL NETWORK CAN COMMUNICATE WITHOUT THE '--publish'/'-p'-FLAG, BUT ONLY THOSE ON THE SAME VIRTUAL NETWORK (GOOD PRACTICE IS TO PUT UNRELATED CONTAINERS ON SEPARATE VIRTUAL NETWORKS)
PUBLISHED CONTAINERS ARE LINKED TO THE HOST NETWORK (AND POSSIBLY INTERNET, IF THE HOST IS CONNECTED) THROUGH THEIR LISTENING PORTS, WHICH MEANS THAT CONTAINERS IN UNRELATED VIRTUAL NETWORKS CAN ONLY SEND PACKAGES TO EACH OTHER VIA THE HOST (AND THE LISTENING PORTS ON THE HOST)
TO GET INFORMATION ON ALL THE NETWORKS THAT ARE BEING USED: 'docker network ls'
TO CREATE A NETWORK, ATTACH A CONTAINER TO THAT NETWORK AND DETACH A CONTAINER TO THAT NETWORK: 'docker network create [OPTIONS]', 'docker network connect [NETWORK NAME OR ID] [CONTAINER NAME OR ID]', 'docker network disconnect [NETWORK NAME OR ID] [CONTAINER NAME OR ID]'
MESSAGING FROM ONE CONTAINER TO ANOTHER CONTAINER OVER A DNS IS BASED ON THE CONTAINER NAMES (WHICH ARE UNIQUE) RATHER THAN IP-ADDRESSES, WHICH MIGHT ALTER
