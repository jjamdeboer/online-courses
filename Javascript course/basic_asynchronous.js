// SYNCHRONOUS CODE IS SEQUENTIALLY HANDLED
// IN ASYNCHRONOUS EXECUTION, SOME FUNCTIONS RUN IN THE BACKGROUND, WHILE OTHER FUNCTION CONTINUE TO EXECUTE. THE BACKGROUND FUNCTION HAS A CALLBACK FUNCTION THAT WILL EXECUTE AS SOON AS THE BACKGROUND FUNCTION IS DONE WITH ITS TASKS. THIS IS LINE OF TACTICS IS IN ORDER TO NOT BLOCK THE PROGRESS IN CASE OF BIG PROCESSES
// EXECUTION WORKS THAT LINES ARE READ AND PUT IN THE QUEUE. FOR EACH LINE THE RELEVANT FUNCTIONS ARE CALLED AND PUT ON THE EXECUTION STACK. AS SOON AS THE FUNCTION IS EXECUTED, THE NEXT THING IN QUEUE IS HANDLED
// ASYNCHRONOUS EXECUTION (SUCH AS DOM-EVENTS, setTimeout, ...) WORKS BY PUTTING THINGS FROM THE EXECUTION STACK INTO A NEW DOMAIN, CALLED WEB APIS, WHICH ARE NOT PART OF THE JAVASCRIPT ENGINE, BUT JAVASCRIPT HAS ACCESS TO IT. AS SOON AS SOMETHING IS CALLED WHICH IS ASYNCHRONOUS, IT MOVES FROM THE EXECUTION STACK TO THE WEB APIS, AND THE CALLBACK FUNCTION OF THE ASYNCHRONOUS FUNCTION IS MOVED TO THE MESSAGE QUEUE AS SOON AS IT IS FINISHED. THE MESSAGE QUEUE IS EXECUTED AS SOON AS THE EXECUTION STACK IS EMPTY
// AJAX STANDS FOR ASYNCHRONOUS JAVASCRIPT AND XML. HTTP-REQUESTS TO AND FROM THE SERVER ARE ALL AJAX-RESPONSES 
// APPLICATION PROGRAMMING INTERFACE (API) IS A LANGUAGE TRANSLATOR, WHICH IS A PART OF THE SERVERS
// FETCH IS A GET-REQUEST IN AJAX WHICH RETURNS A PROMISE
// fetch('url')
// ALSO .then AND .catch CAN BE USED ON IT (SEE BELOW)
// json() CONVERTS JSON TO JAVASCRIPT/A PROMISE 
// AJAX PREVENTS DOMAIN-REQUESTS THAT ARE NOT DONE ON YOUR OWN DOMAIN, TO CIRCUMVENT THIS CROSS-ORIGIN RESOURCE SHARING (CORS) WAS INTRODUCED, WHICH THE SERVER DOMAIN SHOULD IMPLEMENT. WORKAROUND IS TO TYPE https://crossorigin.me/ BEFORE THE URL THAT YOU WANT TO FETCH

// SEVERAL ASYNCHRONOUS FUNCTIONS WHICH DEPEND ON EACH OTHER, IS CALLED 'CALL-BACK HELL' IN JAVASCRIPT AND RESULTS IN VERY LONG RECURSIONS OF CODE. THIS IS SOLVED IN ES6 USING PROMISES
// A PROMISE IS AN OBJECT THAT KEEPS TRACK ON WHETHER AN ASYNCHRONOUS EVENT ALREADY HAPPENED AND DETERMINES WHAT HAPPENS AFTER EVENT TRIGGERS, IMPLEMENTS THE CONCEPT OF EXPECTED FUTURE VALUE
// IF EVENT DIDN'T HAPPEN YET, IT IS PENDING, AFTER IT HAPPENS IT IS SETTLED/RESOLVED, AND IF THE FUTURE VALUE WAS CORRECT, THEN IT IS FULFILLED, OTHERWISE REJECTED
// ONE CAN PRODUCE AND CONSUME PROMISES
// let/const promise = new Promise((resolve, reject) => {do_something_asynchronous_which_will_either_return_resolve_or_reject});
// AND THEN:
// promise.then(resolve => {do_something_when_resolves});
// promise.catch(reject => {do_something_when_rejects});
// OR:
// async function consumePromise() {
//     try {
//         let/const resolve = await promise;
//     }
//     catch{
//         do_something_when_rejecting;
//     }
// }
// consumePromise();
// THE await-KEYWORD CAN ONLY BE USED INSIDE AN async-FUNCTION, WHICH STOPS THE CODE IN THE async-FUNCTION, BUT THIS FUNCTION RUNS IN THE BACKGROUND