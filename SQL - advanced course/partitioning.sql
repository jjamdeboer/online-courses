/* PARTITIONING IS SPLITTING UP TABLES (BEHIND THE SCENES) TO MAKE QUERYING GO FASTER */
/* PARTITIONING CAN BE DONE BASED ON RANGES FOR INTEGER/FLOAT/DATE DATA (1-12 IN PARTITION A, ETC.); 
LISTS FOR CATEGORICAL DATA (ICE IN PARTITION A, ETC.) AND HASHES (PROBABLY HASH BETWEEN asadssasd AND
dasdasdasd IN PARTITION A) */
/* TO LATER ADD A PARTITION FOR A TABLE IS BUMMERS: IT BOILS DOWN TO RENAMING YOUR OLD TABLE, CREATING A 
PARTITIONED NEW TABLE WITH THE OLD NAME AND MOVING THE DATA INTO THIS NEW TABLE; ERGO: NOT POSSIBLE */
/* NOTE THAT IF THE PARTITIONING DOES NOT INCLUDE THE PRIMARY KEY/UNIQUE COLUMNS, THOSE COLUMNS MIGHT ACTUALLY VIOLATE THE 
UNIQUE-CONSTRAINT OVER THE MULTIPLE PARTITIONS, WHICH IS UNWANTED BEHAVIOUR */
/* A SPECIFIC TECHNIQUE FOR PARTITIONING IS INHERITANCE, ALTHOUGH IT IS NOT RECOMMENDED; ONLY FOR DATA WAREHOUSES */

-- SYNTAX >>>
/* SYNTAX FOR PARTITIONING ON VALUE: CREATE TABLE durk( column_name data_type constraints, ... ) PARTITION BY RANGE( column_name_x ); */
/* THEN TO CREATE A SUBTABLE: CREATE TABLE durk_part PARTITION OF durk FOR VALUES FROM lower_bound_inclusive TO upper_bound_exclusive */
/* OPTIONALLY TO ENHANCE SEARCHING: CREATE INDEX ON durk( column_name_x ); */
/* OPTIONALLY FOR A CATCH-ALL PARTITION: CREATE TABLE durk_default PARTITION OF durk DEFAULT; */

/* SYNTAX FOR PARTITIONING ON LIST: CREATE TABLE durk( column_name data_type constraints, ... ) PARTITION BY LIST( column_name_x ); */
/* THEN TO CREATE A SUBTABLE: CREATE TABLE durk_part PARTITION OF durk FOR VALUES IN ( list_of_values ); */
/* OPTIONALLY TO ENHANCE SEARCHING: CREATE INDEX ON durk( column_name_x ); */
/* OPTIONALLY FOR A CATCH-ALL PARTITION: CREATE TABLE durk_default PARTITION OF durk DEFAULT; */

/* SYNTAX FOR PARTITIONING ON HASH: CREATE TABLE durk( column_name data_type constraints, ... ) PARTITION BY HASH( column_name_x ); */
/* THEN TO CREATE A SUBTABLE: CREATE TABLE durk_part PARTITION OF durk FOR VALUES WITH ( MODULUS modulus, REMAINDER remainder ); */
/* OPTIONALLY TO ENHANCE SEARCHING: CREATE INDEX ON durk( column_name_x ); */
/* OPTIONALLY FOR A CATCH-ALL PARTITION: CREATE TABLE durk_default PARTITION OF durk DEFAULT; */
-------------------------------------------------------------------------------- <<<

-- INHERITANCE >>>
/* INHERITANCE WORKS AS FOLLOWS: CREATE TABLE murk( etc. ) INHERITS( durk );
WHERE murk NOW INHERITS ALL NOT NULL AND CHECK CONSTRAINTS FROM durk, BUT NO KEYS AND INDEXES */
/* SINCE KEYS ARE NOT INHERITED, UNIQUE-CONSTRAINT CAN BE VIOLATED IN CHILD TABLE/BETWEEN PARENT-CHILD TABLES */
/* NOTE THAT TABLE CAN INHERIT FROM MULTIPLE TABLES */
/* FURTHERMORE: UPDATE, DELETE AND INSERT CAN BEHAVE UNEXPECTEDLY WITH INHERITANCE */
/* NOTE THAT DATA IS FREELY EXCHANGED FROM THE CHILD TO THE PARENT (NOT THE OTHER WAY) */
/* IN CASE ONE ONLY WANTS DATA FROM EITHER durk, USE: SELECT etc. FROM ONLY durk; */
-------------------------------------------------------------------------------- <<<
