/*THE MOST COMMON FORM OF USING POINTERS IS NAMING VARIABLES: THAT DATA IS NOT DIRECTLY ACCESSED IN MEMORY, BUT THE NAME IS A POINTER TO THAT ADDRESS*/
/*A POINTER IS A VARIABLE THAT STORES A MEMORY ADDRESS, THAT ADDRESS CAN THEN CONTAIN THE SPECIFIED DATA TYPE*/
/*THE COMPILER NEEDS TO KNOW THE DATA TYPE THAT IS STORED IN THE ADDRESS THAT IS POINTED TO, LIKE VARIABLE NAMES*/
/*THAT MEMORY ADDRESS IS STORED AS AN INTEGER, IN HEXADECIMAL FORMAT*/

/*WITH POINTERS, ANY ADDRESS IN MEMORY CAN BE UTILIZED AND ARITHMETIC CAN BE DONE ON IT*/
/*ALSO: POINTERS ALLOW TO REFER TO THE SAME VALUE FROM MULTIPLE LOCATIONS*/
/*THIS CAN POTENTIALLY SAVE A LOT OF MEMORY SPACE, SINCE THE VALUE NEED NOT BE COMMUNICATED, BUT CAN BE POINTED TOWARDS FROM MULTIPLE LOCATIONS*/
/*FURTHERMORE, POINTERS ALLOW TO CHANGE THE VALUE OF VARIABLES PASSED INTO THEM (PASS BY REFERENCE)*/
/*FUNCTIONS CAN NORMALLY ONLY RETURN ONE VALUE, BUT WITH POINTERS THIS RESTRICTION IS NO LONGER APPLICABLE*/
/*ALSO, POINTERS ALLOW TO DYNAMICALLY LOCATE MEMORY DURING RUNTIME, GIVING THE ADVANTAGE THAT WHEN EXTRA MEMORY IS NEEDED, THIS CAN BE ALLOCATED*/
/*POINTERS ALLOW FOR THE CREATION OF COMPLEX STRUCTURES AS: STACK, QUEUE OR LINKED LIST*/
/*A POINTER IS A NEW DATA TYPE, IT CANNOT BE TREATED IDENTICALLY TO AN INTEGER; WITH '%p' AS THE FORMAT SPECIFIER*/

/*TO DECLARE A POINTER, USE: '[DATA TYPE STORED IN THE ADDRESS] * [NAME OF POINTER]'; TO OBTAIN THE ADDRESS OF A VARIABLE, USE '& [NAME OF VARIABLE]'*/
/*IT IS THEREFORE POSSIBLE TO USE: '[DATA TYPE STORED IN THE ADDRESS] * [NAME OF POINTER] = & [NAME OF VARIABLE OF SAME DATA TYPE]'*/
/*FOR INITIALIZING POINTERS: EITHER USE AN ARRAY, A MEMORY ADDRESS OF ANOTHER VARIABLE OR THE VALUE OF ANOTHER POINTER*/
/*RECOMMENDED TO INITIALIZE POINTERS, WHEN THIS IS NOT POSSIBLE YET, IT IS RECOMMENDED TO INITIALIZE THEM WITH THE NULL POINTER (FOR EXAMPLE: 'int *durk = NULL'), WHICH IS INCLUDED IN THE 'stddef.h' LIBRARY*/
/*NULL IS EQUIVALENT TO 0, SO IT IS ALSO POSSIBLE TO DO: [DATA TYPE] * [POINTER NAME] = 0;*/

/*FOR ACCESSING THE VALUE THE POINTER IS POINTING TO/DEREFERENCING THE POINTER, ALSO '*' NEED TO BE USED (FOR EXAMPLE: 'murk = *durk + 1')*/
/*POINTER ARITHMETIC CAN ALSO BE USED TO MOVE AROUND IN MEMORY, WHICH IS ESPECIALLY HANDY WITH ARRAYS*/

/*TO MAKE THE VALUE CONSTANT, USE: 'const [DATA TYPE] * [NAME OF POINTER]', TO MAKE THE POINTER/ADDRESS CONSTANT, USE: '[DATA TYPE] * const [POINTER NAME]'*/

/*SPECIAL TYPES OF POINTERS ARE 'void *' POINTERS, SINCE THE DATA TYPE IS NOT SPECIFIED. THEREFORE, BEFORE ANY OPERATION, THE DEREFERENCING TAKES AN EXTRA STEP OF CASTING THE VARIABLE*/

/*ARRAYS ARE A COLLECTION OF ELEMENTS OF THE SAME DATA TYPE THAT ARE REFFERED BY A SINGLE NAME; THESE NAMES + LOCATION IN THE ARRAY ARE ACTUALLY POINTERS*/
/*ARRAYS AND POINTERS CAN BE USED INTERCHANGEABLY; TO POINT TO THE FIRST ELEMENT OF AN ARRAY, USE, FOR EXAMPLE: 'int array[100]; int * parray; parray = array'; THIS IS EQUIVALENT TO: 'int array[100]; int * parray; parray = &array[0]*/
/*NOTE THAT 'array[i]' AND *(array + i) HAVE THE SAME MEANING*/
/*POINTER ARITHMETIC CAN NOW BE USED TO ITERATE THROUGH ARRAYS: 'int array[100]; int * parray; parray = array; *parray = [SET VALUE FOR THE FIRST ELEMENT OF THE ARRAY]; parray++; *parray = [SETS THE VALUE FOR THE SECOND ELEMENT OF THE ARRAY]' ETC.*/
/*WARNING THAT THIS CAN LEAD TO OUT-OF-BOUND-ERRORS, SO BE AWARE OF THE BOUNDS*/

/*PASS BY REFERENCE IS PASSING IN POINTERS TO FUNCTIONS, GIVING THE POSSIBILITY OF RETURNING MORE VALUES FROM ONE FUNCTION*/
/*PASS BY VALUE IS DEFAULT IN C, BUT PASS BY REFERENCE IS APPROACHED BY PASSING IN ADDRESSES TO FUNCTIONS*/
/*PASS BY VALUE MEANS THAT THE VALUE OF THAT ARGUMENT IS COPIED TO THE VALUE OF THAT ARGUMENT, SO THE ORIGINAL VALUE REMAINS UNTOUCHED*/
/*THIS IS THE SAME WITH POINTERS, HOWEVER WHEN DEREFERENCING THE POINTER, THE VALUE OF WHERE THE ADDRESS IS POINTING TO CAN BE CHANGED*/

/*ASSIGNING A VALUE TO MEMORY IS NORMALLY DONE WITH: '[DATA TYPE] [VARIABLE NAME] = [VARIABLE VALUE]'; ESPECIALLY THE DATA TYPE GIVES INSTRUCTIONS ON HOW MUCH MEMORY TO RESERVE FOR THAT VARIABLE (WHERE POINTERS ARE UNDERSTOOD AS BEING A DIFFERENT DATA TYPE)*/
/*IT IS ALSO POSSIBLE TO CREATE A POINTER AND TO NOT ASSIGN IT TO THE MEMORY OF AN EXISTING VARIABLE, BUT TO, NEVERTHELESS, RESERVE SOME SPACE IN MEMORY FOR IT. THIS IS DYNAMIC ALLOCATION OF MEMORY TO A POINTER*/
/*IN MOST CASES, FIXED SIZES FOR, FOR EXAMPLE, ARRAYS ARE USED (FOR EXAMPLE: 'int durk[1024]'). THIS, HOWEVER, DOES GIVE AN ULTIMATE CONSTRAINT ON THE SIZE OF THAT ARRAY*/
/*THERE ARE TWO CONCEPTS FOR STORING DATA IN A PROGRAM. DATA CAN BE STORED IN THE HEAP (THE HEAP IS USED FOR DYNAMIC MEMORY ALLOCATION) OR IN THE STACK (FUNCTION ARGUMENTS AND LOCAL VARIABLES AND ALSO FUNCTIONS THEMSELVES (THINK OF THE CALL STACK); AFTER FUNCTION EXITS, THIS MEMORY GETS DELETED)*/
/*HEAP IS REALLY STORED FOR DURING THE DURATION OF THE PROGRAM AND THIS IS UNDER DIRECT CONTROL OF THE USER; THE STACK IS AUTOMATICALLY CREATED AND DELETED AS PROGRAM RUNS*/
/*IT IS ALSO POSSIBLE TO ALLOCATE MEMORY WHEN NEEDED (SO, DYNAMICALLY; THIS IS ONLY POSSIBLE BECAUSE C HAS POINTERS)*/
/*THERE ARE DIFFERENT FUNCTIONS FOR ALLOCATING AND DEALLOCATING MEMORY: 'malloc([NUMBER OF BYTES TO BE ALLOCATED/RESERVED])' (RETURNS THE ADDRESS/POINTER OF THE FIRST ALLOCATED BYTE; INCLUDED IN 'stdlib.h') (FOR EXAMPLE: 'int * durk = (int *) malloc (1024)' OR: 'int * durk = (int *) malloc(33*sizeof(int))', CREATING AN ARRAY FOR INTEGERS); IT IS GOOD TO RELEASE THE MEMORY WHEN ALLOCATED (FOR EVERY 'OPEN' SHOULD BE A 'CLOSE'), A MEMORY LEAK OCCURS WHEN MEMORY IS RESERVED, BUT CANNOT BE REFERENCED ANYMORE DURING THE PROGRAM AND, THUS, DOES NOT GET RELEASED; TO RELEASE MEMORY: 'free([MEMORY ADDRESS/POINTER])' (FOR EXAMPLE: 'free(durk); durk = NULL'; WHERE THE SECOND STATEMENT SHOULD BE ADDED TO MAKE SURE THAT 'durk' DOES REFERENCE RANDOM MEMORY); FOR ALLOCATING AND INITIALIZING THE MEMORY TO 0, ESPECIALLY THE INITIALIZATION IS CONVENIENT: 'calloc([NUMBER OF ITEMS FOR WHICH MEMORY IS REQUIRED], [SIZE OF EACH ITEM])' (FOR EXAMPLE: 'int * durk = (int *) calloc(33, sizeof(int))'); FOR REUSING OR EXTENDING OR DIMINISHING THE MEMORY PREVIOUS ALLOCATED WITH 'malloc' OR 'calloc', USE: 'realloc([OLD ADDRESS/POINTER], [SIZE IN BYTES NEEDED FOR NEW STORAGE])' (FOR EXAMPLE: 'int * durk = (int *)realloc(murk, 33*sizeof(int))'; IMPORTANT TO NOTE IS THAT 'murk' IS STILL PRESERVED AND THE VALUES FOR THOSE ADDRESSES AS WELL, SO IT MORE OR LESS EXTENDS THE PREVIOUS ADDRESS TO THE NEW ADDRESS, BUT DOES NOT THROW AWAY THE OLD ADDRESS, THAT MUST STILL BE EXPLICITLY RELEASED)*/
/*SINCE 'malloc' RETURNS A VOID POINTER, POINTER CASTING IS ESSENTIAL*/
/*IMMEDIATELY CHECK FOR NULL WHEN USING 'malloc' OR 'calloc', SINCE WHEN THE MEMORY IS NOT ALLOCATED, A NULL IS RETURNED*/
/*NOTE THAT THE 'sizeof'-OPERATOR IS ESSENTIAL WHEN WORKING WITH MEMORY ALLOCATION*/

#include <stdio.h>
#include <stddef.h>
#include <string.h>
#include <stdlib.h>

int * square(int durk, int * murk){
    
    durk *= durk;
    * murk *= * murk;

    return murk;

}

int main(void){

    int integer = 50;
    int * pinteger = & integer;
    * pinteger += * pinteger * 2.5;

    int array[2];
    int * parray;
    parray = array;
    *parray = 900;
    parray++;
    *parray = 3;

    char word[] = "WOOOOOOOOOOOOORD!";
    char * pword;

    char * wordy;
    int integrity;

    int durk = 90, murk = 800;

    printf("INTEGER AND IT'S ADDRESS: %i, %i, %p, %p\n", integer, * pinteger, pinteger, & integer);
    printf("THE ADDRESS OF THE POINTER IS: %p\n", & pinteger);

    printf("THE VALUES OF THE ARRAY ARE: %i, %i\n", array[0], array[1]);

    for (pword = word; * pword != '\0'; printf("%c", * pword), pword++);
    printf("\n");
    /*WHICH IS THE SAME AS:*/
    for (pword = word; * pword; printf("%c", * pword), pword++);
    printf("\n");

    int * jurk = square(durk, &murk);
    printf("SQUARING 90 AND 800 BY REFERENCE AND BY ADDRESS RESPECTIVELY: %i, %i, %i\n", durk, murk, * jurk);

    printf("ENTER NUMBER OF CHARACTER YOU WANT TO PRINT:\n");
    scanf("%i", &integrity);
    printf("ENTER THE CHARACTERS:\n");
    wordy = (char *)calloc(integrity + 1,sizeof(char));
    if (wordy){
        scanf("%s",wordy);
        printf("THE ENTERED STRING IS AND ITS MEMORY IS: %s, %p\n", wordy, wordy);
        free(wordy);
        wordy = NULL;
        printf("AFTER RELEASING, THE STRING IS: %s, %p\n", wordy, wordy);
    }

    return 0;
}
