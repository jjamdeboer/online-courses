/*STRUCTURES ARE SIMILAR TO OBJECTS, BUT WITHOUT METHODS; IT GROUPS DATA TOGETHER*/
/*STRUCTURES ARE, LIKE ENUMERATIONS, A WAY IN C TO DEFINE A, COMBINED, NEW DATA TYPE; HOWEVER ENUMERATIONS HOLD ONLY ONE VALUE, WHEREAS A STRUCTURE CAN HOLD MULTIPLE*/
/*EXAMPLES ARE DATES, WHICH CAN THEN BE GROUPED TOGETHER*/
/*THE DIFFERENT DATA ATTRIBUTES (FOR EXAMPLE: 'months') ARE CALLED MEMBERS OF THE STRUCTURE*/

/*TO DECLARE A STRUCTURE, USE: 'struct [STRUCT NAME] { [DATA TYPE] [MEMBER NAME]; [DATA TYPE] [MEMBER NAME TWO] ...};' (FOR EXAMPLE: 'struct date {int day; int month; int year};')*/
/*THESE DATA TYPES WITHIN STRUCTURES CAN ALSO INCLUDE POINTERS, SO THIS IS QUITE POWERFUL*/
/*TO INITIALIZE AN INSTANCE OF THAT STRUCTURE, THE SYNTAX IS SIMILAR TO THE SYNTAX OF AN ENUMERATION, NAMELY: 'struct [STRUCTURE NAME] [INSTANCE NAME]' (FOR EXAMPLE: 'struct date GerardsBirthday')*/
/*THERE ARE OTHER WAYS OF DEFINING AND INITIALIZING STRUCTURES, SUCH AS: 'struct [STRUCT NAME] {[DATA TYPE] [MEMBER NAME]; ...} [INSTANCE NAME], [ANOTHER INSTANCE NAME], ...;' (WHICH DEFINES A STRUCTURE AND IMMEDIATELY INITIALZES AN INSTANCE); OR FOR ANONYMOUS STRUCTURES: 'struct {[DATA TYPES] ...} [INSTANCE NAME], [ANOTHER INSTANCE NAME], ...' (NOTE THAT THIS CAN ONLY BE USED ONCE); OR FOR INITIALIZATION: '[INSTANCE NAME] = {[FIRST MEMBER VALUE], [SECOND MEMBER VALUE], ...}', VERY SIMILAR TO AN ARRAY, NOTE THAT NOT ALL MEMBERS HAVE TO BE GIVEN A VALUE AT INITIALIZATION; ANOTHER WAY IS: '[INSTANCE NAME] = {.[MEMBER NAME] = [MEMBER VALUE], ...}', SO THAT THE ORDER CAN BE REARRANGED, DO NOTE THE '.' BEFORE THE MEMBER NAME*/
/*SINCE THERE IS NOW A DECLARATION OF A DATA TYPE, TYPECASTING CAN ALSO HAPPEN: '[INSTANCE NAME] = (struct [STRUCT NAME]) {[MEMBER VALUE], ...}'*/
/*STRUCTURE VARIABLE NAMES ARE, UNLIKE STRINGS AND ARRAYS, NOT POINTERS. THEREFORE, TO ACCESS THE MEMBERS, USE: '[INSTANCE NAME].[MEMBER NAME]' (FOR EXAMPLE: 'GerardsBirthday.day = 21'); THE PERIOD USED TO ACCESS THAT MEMBER IS CALLED THE MEMBER SELECTION/DOT OPERATOR*/

/*IT IS POSSIBLE TO MAKE ARRAYS OF STRUCTURES, SINCE FROM THE DECLARATION ONWARD, C CONSIDERS THE STRUCTURE AS A SEPARATE DATA TYPE*/
/*NATURALLY IT IS ALSO POSSIBLE TO MAKE STRUCTURES THAT CONTAIN ARRAYS AS MEMBERS*/
/*ALSO, NATURALLY, STRUCTURES CAN BE MEMBERS OF OTHER STRUCTURES; THIS IS ALSO CALLED 'NESTED STRUCTURES'*/
/*HOWEVER, FOR NESTED DECLARATIONS, THE INSIDE STRUCTURE CANNOT BE USED OUTSIDE OF THAT ENCLOSING STRUCTURE (IF IT IS REALLY DEFINED ONLY IN THAT ENCLOSING STRUCTURE, WHICH IS VALID SYNTAX)*/

/*BOTH OF THE FOLLOWING ARE ALLOWED: POINTERS OF STRUCTURES AND MEMBERS THAT ARE POINTERS*/
/*POINTERS TO STRUCTURES ARE SLIGHTLY EASIER TO MANIPULATE THAN STRUCTURES THEMSELVES DUE TO NOTATION*/
/*PASSING POINTERS TO A FUNCTION IS ALSO MORE EFFICIENT THAN PASSING THE STRUCTURE ITSELF, SO IMPORTANT TO DO THIS, INSTEAD OF COPYING THE WHOLE STRUCTURE TO THE LOCAL PARAMETER*/
/*SINCE THE DOT HAS HIGHER PRECEDENCE THAN THE ASTERISK, IT IS MANDATORY TO ENCLOSE THE POINTER IN BRACKETS WHEN DEREFERENCING IT, BEFORE USING DOT NOTATION ON IT (FOR EXAMPLE: '(*dateexample).year')*/
/*HOWEVER, TO DEREFERENCE A POINTER TO A STRUCTURE ANOTHER NOTATION IS ALSO ALLOWED: '[POINTER NAME] -> [MEMBER]' (FOR EXAMPLE: 'dateexample -> year')*/
/*THERE IS AN IMPORTANT DIFFERENCE BETWEEN POINTERS AND ALLOCATED ARRAYS THAT BECOMES VERY APPARENT IN STRUCTURES: WHEN A POINTER WITHIN A STRUCTURE GETS AN ASSIGNMENT, IT ONLY STORES THE ADDRESS TO THAT STRING/ARRAY, BUT NOT THE ARRAY ITSELF. IF IT IS NOT DECLARED AS A POINTER, BUT AS AN ARRAY WITH A SIZE, THEN THE VALUES CAN BE STORED WITHIN THE STRUCTURE*/
/*HOWEVER, IT IS POSSIBLE TO ALSO PUT THE ARRAY OR STRING WITHIN THE STRUCTURE, BUT THEN THE MEMORY HAS TO BE DYNAMICALLY ALLOCATED USING 'malloc' OR 'calloc' TO CREATE ENOUGH SPACE; SINCE IT IS DECLARED A POINTER IT ONLY HAS ENOUGH SPACE AT FIRST FOR ONE ADDRESS, SO LARGER STRINGS CANNOT BE STORED THERE, SO DYNAMIC ALLOCATION IS ESSENTIAL IN STRUCTURE THAT HAVE POINTERS AS MEMBERS*/
/*ANOTHER SOLUTION IS TO DECLARE THE STRINGS OR ARRAYS ELSEWHERE AND THEN LET THE POINTERS POINT TO THESE INSTANCES, THAT IS PERFECTLY FINE*/

#include <stdio.h>
#include <stdlib.h>
#include <strings.h>

struct arrayexperiment {
    int * array;
    char * description;
};

int main ( void ){

    struct date {
        int day;
        int month;
        int year;
        char * description;
    };

    struct date birthday;
    struct date otherbirthday = { 7, 3, 2050, "OTHER BIRTHDAY" };

    birthday.day = 5; birthday.month = 11; birthday.year = 1987; birthday.description = "BIRTHDAY";
    /*otherbirthday = birthday;*/

    struct date datearray[2];
    struct date * anotherdatearray;
    anotherdatearray = datearray;
    struct date * durumdate;

    datearray[0] = birthday;
    datearray[1] = birthday;
    *anotherdatearray = birthday;
    *( anotherdatearray + 1 ) = otherbirthday;
    /*TO PROVE THAT A STRUCTURE IS NOT A POINTER:*/
    otherbirthday = ( struct date ) { .year = 2022, "MUUURK" };
    /*TO GIVE THIS POINTER THE MEMORY ADDRESS OF THE OTHER STRUCTURE:*/
    durumdate = &otherbirthday;
    durumdate -> month = 9;
    durumdate -> day = 13;

    printf( "BIRTHDAY IS %i/%i/%i, HOORAY %c\n", birthday.day, birthday.month, birthday.year, birthday.description[4] );
    printf( "BIRTHDAY IS %i/%i/%i, HOORAY %s\n", birthday.day, birthday.month, birthday.year, birthday.description );
    printf( "OTHER BIRTHDAY IS %i/%i/%i, HOORAY %s\n", otherbirthday.day, otherbirthday.month, otherbirthday.year, otherbirthday.description );
    /*THIS PROVES THAT A STRUCTURE IS NOT A POINTER, ONCE SET IT IS SET (CAN BE CHANGED, BUT REFERENCES DON'T CHANGE)*/
    printf( "BIRTHDAY ARRAY IS %i/%i/%i, HOORAY %s\n", datearray[1].day, datearray[1].month, datearray[1].year, datearray[1].description);
    printf( "DURUM BIRTHDAY IS %i/%i/%i, HOORAY %s\n", (*durumdate).day, durumdate -> month, (*durumdate).year, durumdate -> description); 

    int array[] = { 600, 700, 77, 89, 1 };
    char * description = "WHAT WHAT WHAT";

    struct arrayexperiment structureofarrays;
    structureofarrays.array = array;
    structureofarrays.description = description;

    printf("EXPERIMENT WITH STRUCTURE OF ARRAYS: %i, %i, %i, %i, %c, %s\n", *(structureofarrays.array), *(structureofarrays.array + 2), *(structureofarrays.array + 4), structureofarrays.array[0], *(structureofarrays.description + 7), structureofarrays.description);

    int integer = 9000;
    structureofarrays.array = &integer;

    printf("ANOTHER EXPERIMENT WITH A STRUCTURE OF POINTERS: %i, %c\n", *(structureofarrays.array), *(structureofarrays.description + 7));

    return 0;

}
