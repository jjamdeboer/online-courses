/*SIMPLE PROCESSES DO ONE THING AT THE TIME*/
/*NOT ALL TASKS CAN BE DONE WITH A SINGLE PROCESS*/
/*IN MOST CASES, THE 'main'-FUNCTION IS A SINGLE PROCESS, BUT IT CAN BE CHANGED INTO MULTIPLE PROCESSES BY 'fork' AND OTHER COMMANDS*/
/*HOWEVER, CREATING A PROCESS FOR EACH TASK IS NOT EFFICIENT, SINCE CREATION OF A PROCESS TAKES A LONG TIME, AND PROCESSES CANNOT EASILY SHARE MEMORY*/
/*THREADS ARE A WAY TO SOLVE THESE PROBLEMS: THEY CREATE A SEPARATE PATH OF EXECUTION WITHIN THE PROGRAM, THAT'S FAST TO START UP AND BREAK DOWN AND SHARES MEMORY WITH THE OVERARCHING PROCESS*/

/*THREADS ARE SOMETIMES REFERRED TO AS 'LIGHTWEIGHT PROCESSES'*/
/*A THREAD HAS ITS OWN ID, PROGRAM COUNTER, A REGISTER SET AND A STACK SPACE, LIKE A PROCESS, HOWEVER, THREADS SHARE THE SAME ADDRESS SPACE AND THUS HAVE ACCESS TO THE SAME MEMORY AS THE OTHER THREADS AND MAIN PROCESS, UNLIKE PROCESSES*/
/*EACH THREAD RUNS INDEPENDENTLY; A THREAD RUNNING IS ALSO REFERRED TO AS 'A THREAD OF EXECUTION'*/
/*AS DISADVANTAGES: THREADS CAN RESULT IN VERY UNCLEAR ERRORS, PRONE TO DEADLOCKING, PRONE TO TWO THREADS ACCESSING THE SAME MEMORY AT THE SAME TIME (THREAD SYNCHRONIZATION), THIS RESULTS IN INCONSISTENT DATA AT BEST*/
/*THERE IS NO IMPLIED HIERARCHY OR DEPENDENCY BETWEEN THREADS (UNLIKE PROCESSES)*/

/*IN 1995, POSSIX BECAME THE STANDARD FOR MANY SYSTEM CALLS IN UNIX, INCLUDING THE THREADING ENVIRONMENT; THIS IS RELEVANT BECAUSE THREADS ARE NOT AN INTEGRAL PART OF C; THIS STANDARD IS ENCAPSULATED IN THE 'pthread.h'-LIBRARY*/
/*THIS POSSIX-STANDARD, RESULTING IN POSSIX-THREADS ('pthreads'), IS ALSO USED IN JAVA AND PYTHON*/
/*BEWARE THAT FOR COMPILING YOU NEED TO LINK TO THAT LIBRARY: '-lpthread'*/

/*THREE CATEGORIES FOR THREAD-FUNCTIONS: THREAD MANAGEMENT, SYNCHRONIZATION, CONDITION VARIABLES*/
/*CREATION OF A THREAD IS NOT DONE WITH 'fork', BUT WITH A FUNCTION THAT IS DEFINED AS A THREAD-FUNCTION*/
/*FOR CREATION: 'pthread_create([POINTER TO 'pthread_t'/INTEGER, CONTAINS THREAD ID], [POINTER TO 'pthread_attr_t', CONTAINS THREAD ATTRIBUTE], [POINTER TO A VOID-FUNCTION AS '(void *)(* [FUNCTION NAME])(void *)], [ARGUMENT TO THE FUNCTION, NEEDS TO BE CAST TO A 'void *'-TYPE])'*/
/*ONE CAN ALSO JOIN CURRENT THREAD WITH ANOTHER THREAD (AND GIVES A CONDITION ON WHEN TO JOIN THE THREADS): 'pthread_join([ID OF THREAD, OF 'pthread_t'-TYPE], [SECOND ARGUMENT IS PASSED TO 'pthread_exit', CAN BE CHOSE TO BE NULL, IS OF TYPE 'void ** [VALUE POINTER]'])'*/
/*TO TERMINATE A THREAD (WHICH ALSO AUTOMATICALLY HAPPENS WHEN THE MAIN-THREAD STOPS): 'pthread_exit([void * [VALUE POINTER THAT IS ALSO USED IN THE 'pthread_join'-FUNCTION]])'*/
/*TO COMPARE TWO THREAD ID'S, '==' DOESN'T PARTICULARLY WORK, SO 'pthread_equal([ID ONE], [ID TWO])' SHOULD BE USED*/
/*TO CANCEL A PARTICULAR THREAD, USE 'pthread_cancel([THREAD ID])'*/

/*RACE CONDITIONS AND DEADLOCKS ARE CONCEPTS THAT CAN OCCUR WITH THREADS:*/
/*- RACE CONDITION: RESULTS OF DIFFERENT THREADS DEPENDS ON THE ORDER IN WHICH THREADS ARE EXECUTED*/
/*- DEADLOCK: MULTIPLE THREADS LOCK RESOURCES, BUT ALSO MUTLIPLE THREADS ARE TRYING TO ACCESS THOSE RESOURCES, RESULTING IN AN INDEFINITE WAITING PERIOD*/
/*THREAD SAFE CODE IS CODE THAT IS NOT PRONE TO SUCH MEMORY ERRORS*/
/*WAYS TO PROTECT SHARED DATA IS BY MUTUAL EXCLUSION (MUTEX), ATOMIC OPERATIONS AND CONDITION VARIABLES*/
/*MUTEXES ARE MEMORY LOCKS THAT ENSURE THAT ONLY ON THREADS ACCESSES THAT SPECIFIC PART OF MEMORY*/
/*ATOMIC OPERATIONS ARE OPERATIONS THAT ARE TOO SMALL FOR MULTIPLE THREADS TO ACCES THEM SIMULTANEOUSLY*/
/*CONDITION VARIABLES ARE NOTIFICATIONS BETWEEN THREADS*/

/*MUTEXES CAN BE DEFINED BY 'pthread_mutex_t [MUTEX VARIABLE NAME] = PTHREAD_MUTEX_INITIALIZER' (WHICH IS A MACRO FROM 'thread.h'), OR 'pthread_mutex_init([POINTER TO A 'pthread_mutex_t' VARIABLE], [ATTRIBUTE TO THE MUTEX, OF TYPE 'pthread_mutexattr_t'])'*/
/*FOR DESTROYING A MUTEX VARIABLE: 'pthread_mutex_destroy([MUTEX VARIABLE])'*/
/*FOR ACCESSING A MUTEX VARIABLE, USE: 'pthread_mutex_lock([MUTEX VARIABLE])' (WHICH RESULTS IN WAITING IF THE MUTEX IS ALREADY LOCKED), OR: 'pthread_mutex_trylock([MUTEX VARIABLE])' (WHICH DOESN'T)*/
/*FOR FREEING THE MUTEX, USE 'pthread_mutex_unlock([MUTEX VARIABLE])', WHICH CAN ONLY BE DONE IF THE CALLING THREAD IS CURRENTLY LOCKING THAT MUTEX*/
/*IDENTICALLY, CONDITION VARIABLES CAN BE FREED, CREATED AND DESTROYED, REPLACING 'mutex' WITH 'cond'*/


#include <stdio.h>
#include <pthread.h>
#include <stdlib.h>

void * hello_world( void * murk ){
    
    int durkudurk = * (int *) murk;
    printf( "HELLO WORLD, %i\n", durkudurk );
    printf( "THREAD ID IS %li\n", pthread_self() );
    /*exit(0);*/
    /*abort();*/
    pthread_exit( NULL );


}

int main( void ){

    pthread_t id = 0, id_two = 0;
    int murk = 90;
    int * durk = & murk;
    pthread_create( &id, NULL, hello_world, (void *) durk );
    pthread_create( &id_two, NULL, hello_world, (void *) durk );
    pthread_join( id, NULL );
    pthread_join( id_two, NULL );
    printf( "MAIN THREAD ID IS %li\n", pthread_self() );
    printf( "DUUUUUUUUUURK!\n" );
    /*pthread_exit( NULL );*/
    printf( "DUUUUUUUUUURK!\n" );

    return 0;


}
