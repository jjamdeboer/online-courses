/*A PROCESS IS A PROGRAM IN EXECUTION*/
/*EACH PROCESS HAS ITS OWN MEMORY SPACE AND USUALLY ONE THREAD OF CONTROL*/
/*PROCESSES ARE ORGANIZED HIERARCHICALLY*/
/*EVERY PROCESS HAS A UNIQUE ID (PID)*/

/*THERE CAN BE INDEPENDENT PROCESSES AND THERE CAN BE CO-OPERATING PROCESSES (WHETHER THEY ARE AFFECTED BY OTHER PROCESSES)*/
/*MESSAGES BETWEEN PROCESSES OFTEN REFERRED TO AS 'INTERPROCESS COMMUNICATION' (OR: 'IPC')*/
/*FORMS OF IPC ARE:*/
/*- PIPES (FIRST PROCESS COMMUNICATES WITH SECOND PROCESS AND ONLY IN ONE DIRECTION [ALSO CALLED: 'HALF DUPLEX'])*/
/*- NAMED PIPES (BOTH PROCESSES CAN COMMUNICATE BOTH WAYS [ALSO CALLED: 'FULL DUPLEX'])*/
/*- MESSAGE QUEUE (BOTH PROCESSES PUT THEIR MESSAGES IN A QUEUE, ALSO FULL DUPLEX)*/
/*- SHARED MEMORY*/
/*- SOCKETS*/
/*- SIGNALS (SOURCE PROCESS SENDS A SIGNAL WITH AN INTEGER AND THEN THE RIGHT DESTINATION PROCESS WILL PICK IT UP; THIS SIGNAL IS USUALLY RELATED TO THE STATE OF THE PROCESS)*/

/*WHEN A SIGNAL IS SENT, THE RECEIVING PROCESS IS INTERRUPTED BY THE OPERATING SYSTEM IN ORDER TO RECEIVE*/
/*THE KINDS OF SIGNALS THAT CAN BE SENT IS LIMITED AND DEFINED BY THE OPERATING SYSTEM*/
/*EXAMPLES ARE: 'CTRL + C' ~ SIGINT, 'CTRL + Z' ~ SIGSTOP, 'fg' OR 'bg' ~ SIGCONT*/
/*THE LIBRARY FOR CREATING AND HANDLING SIGNALS IS 'signal.h'*/
/*'raise([SIGNAL ID])' SENDS A SIGNAL TO CURRENT PROCESS AND LIKEWISE 'kill([SIGNAL ID])' SENDS A SIGNAL TO A SPECIFIC PROCESS*/
/*WHEN A PROCESS IS STOPPED, IT CAN BE STARTED AGAIN (SIGSTOP AND SIGCONT ARE COMPLEMENTARY)*/
/*THE 'alarm()'-FUNCTION ENABLES A PROCESS TO INTERRUPT ITSELF AFTER A TIMER REACHES A LIMIT; WHEN THE TIMER EXPIRES, A SIGALARM IS SENT*/
/*THERE ARE TWO WAYS OF HANDLING/CATCHING SIGNALS: 'signal' AND 'sigaction'*/
/*WAYS OF RESPONDING TO SIGNALS ARE: IGNORING, LET THE DEFAULT EXECUTE AND HANDLE THE SIGNAL SPECIFICALLY*/
/*THE FUNCTIONS AND PARAMETERS ARE: 'signal([SIGNAL INTEGER TO RESPOND TO], [FUNCTION POINTER TO A FUNCTION THAT SHOULD BE EXECUTED WHEN RECEIVING SUCH A SIGNAL])'*/
/*AND: 'sigaction([SIGNAL INTEGER], [NEW ACTION YOU WANT PERFORMED], [OLD ACTION THAT WAS PERFORMED])'*/

/*A PROGRAM CAN CONTAIN MULTIPLE TASKS AND SPIN OFF MULTIPLE PROCESSES*/
/*THREADS ARE A SAFER WAY OF SPINNING UP NEW PROCESSES, HOWEVER NEW PROCESSES CAN ALSO BE 'FORKED' FROM THE PARENT PROCESS*/
/*THE CHILD PROCESS HAS AN EXACT COPY OF THE MEMORY OF THE PARENT, SO FROM THAT MOMENT ON, THESE ARE GENUINELY TWO DIFFERENT PROCESSES (CHANGING STATE OF ONE DOESN'T CHANGE THE STATE OF THE OTHER)*/
/*THE FORK-FUNCTION IS IN THE LIBRARY 'unistd.h'*/


#include <unistd.h>
#include <signal.h>
#include <stdio.h>

/*BOTH THESE FUNCTIONS ARE EQUIVALENT:*/
/*void nothing( int num ){ };*/
void nothing( int num ){ SIGCONT; };

int main( void ){

    int pid = fork();
    /*BOTH THESE FUNCTIONS ARE EQUIVALENT:*/
    /*signal( SIGINT, nothing );*/
    signal( SIGINT, SIG_IGN );

    printf( "PID IS %i\n", pid );
    raise( SIGINT );

    /*RANDOM ORDER OF PRINTING NUMBERS:*/
    printf( "UNONDERLY PRINTING OF NUMBERS WITH FORKED PROCESSES: \n" );
    for( int j = 0; j <= 9; j++ ){
        printf( "NUMBERS AND PID: %i, %i\n", j, pid );
    }
    /*ORDERLY ORDER OF PRINTING NUMBERS WITH FORKED PROCESSES:*/
    printf( "ORDERLY PRINTING OF NUMBERS WITH FORKED PROCESSES: \n" );
    for( int j = 0; j <= 9; j++ ){
        sleep(.5);
        printf( "NUMBERS AND PID: %i, %i\n", j, pid );
    }
    if( pid == 0 ){
        printf( "PARENT PRINTING NUMBERS:\n" );
        for( int j = 0; j <= 9; j++ ){
            printf( "NUMBERS AND PID: %i, %i\n", j, pid );
            printf( "OWN PID AND PARENT ID: %i, %i\n", getpid(), getppid() );
        }
    }
    return 0;


}
