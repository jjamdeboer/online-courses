SPARK USES CACHING; IT IS IMPORTANT FOR PERFORMANCE TO KNOW HOW AND WHEN TO PERSIST RDD'S
PERSISTING TO DISK IS USEFUL IN CASE OF EXPENSIVE OPERATIONS, OTHERWISE PERSIST TO MEMORY WILL SUFFICE
EXAMPLE WHEN TO PERSIST (AFTER PRUNING, FILTERING OR OTHER TRANSFORMATIONS): LOADING, PARSING AND PARTITIONING BY KEY OF A DATA FILE
FOR REDOING A PERSISTENCE, CALL FUNCTION UNPERSIST
SPARK USES LEAST RECENTLY USED (LRU) FOR MAKING ROOM FOR RDD'S
CACHE-FUNCTION USES DEFAULT MEMORY-ONLY, WITH PERSIST-FUNCTION OTHER FUNCTIONS ARE AVAILABLE

RAW DATA TAKES MOST SPACE, SAVING SPACE CAN BE ACHIEVED BY SERIALIZATION: CREATING ONE LARGE BYTE ARRAY FROM THE DATA
COMPRESS ALSO OPTION; BOTH SERIALIZATION AND COMPRESSION COMES AT COST OF DE-SERIALIZATION AND DECOMPRESSING
USE PRIMITIVE TYPES AND AVOID USING NESTED FUNCTIONS FOR SPEED OPTIMIZATION
KRYO IS A GOOD SERIALIZER (BETTER THAN THE STANDARD JAVA SERIALIZER), BUT AT THE COST OF BEING INCOMPATIBLE

RDD'S CANNOT BE SHARED ACROSS APPLICATIONS; TACHYON IS MEMORY-BASED DISTRIBUTED FILE SYSTEM (INCLUDED IN SPARK) ALLOWS FOR SHARING ACROSS APPLICATIONS
