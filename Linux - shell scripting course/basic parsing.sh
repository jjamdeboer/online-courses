#!/bin/bash

# THE CASE STATEMENT CAN BE USED TO MATCH A PATTERN TO DIFFERENT OBJECTS, PREFERRED OVER ENDLESS ELIF-STATEMENTS:
if [[ $DURK == 'DURK' ]]
then echo DUUUUUUUUUUUUUUUUURK
elif [[ $DURK == 'MURK' ]]
then echo MUUUUUUUUUUUUUUUUUURK
elif [[ $DURK == 'DURKUDURK' ]]
then echo DURKUDUUUUUUUUURK
else echo WOTWOTWOT?
fi
# SYNTAX OF CASE IS: case [WORD] in [PATTERN1|PATTERN2|PATTERN...]) [COMMAND FOR THESE SPECIFIC PATTERNS] ;; [PATTERN...|...]) [COMMAND FOR THESE SPECIFIC PATTERNS] ;; [ETC.] ;; esac
# EQUIVALENT TO:
case $DURK in 
	'DURK') echo DUUUUUUUUUUUUURK;; 
	'MURK') echo MUUUUUUUUUUUUUUUUUURK;; 
	'DURKUDURK') echo DURKUDUUUUUUUUURK;; 
	*) echo WOTWOTWOT?;;
esac
case $DURK in 'DURK'|'MURK'|'DURKUDURK') echo DUUUUUUUUUURK;; *) echo WOTWOTWOT? ;; esac

# TO DEFINE FUNCTIONS, USE: function [NAME] {[COMMANDS];}, OR, ALTERNATIVELY: [NAME] () {[COMMANDS];}
# LOCAL VARIABLES ARE ONLY IN SCOPE OF THE FUNCTIONS, LOCAL VARIABLES OVERRIDE EXISTING VARIABLES IN SCOPE, EXCEPT WHEN THAT VARIABLE IS READONLY
# ONLY FUNCTIONS HAVE LOCAL SCOPE IN BASH
readonly MURK=MURK
DURK=DURK
function MURK { local MURK=$*; echo MURKUMURK; echo MURK $DURK $MURK; echo MUUUUUUUURK; }
MURK durk murk durk murk durkudurkmurk
echo FUNCTION IS NOT A VARIABLE HERE, SINCE MURK IS NOT THE FUNCTION VALUES, BUT MURK: $MURK

# ALLOWING THE USER TO GIVE OPTIONS TO SCRIPTS AND FUNCTIONS: getopts
# IMPORTANT FOR USE: getopts [CHARACTERS, MANDATORY CHARACTERS FOLLOWED BY COLON] [VARIABLE NAME]
# GENERAL USAGE:
while getopts du:rk OPTION
do
	case $OPTION in
		d) echo DURK?;;
		u) echo HAD JE MOETEN DOEN JONGEN; MURK;;
		r) echo RAAAAAAAAAR;;
		k) echo KUT;;
		*) echo INVALID OPTION >&2;;
	esac
done

# ARETHMATIC EXPENSION IS $(( [TO BE EVALUATED EXPRESSION] )), OTHER THAN EXPRESSION WHICH IS SIMPLY $( [TO BE EVALUATED EXPRESSION] ); FURTHERMORE THE '$' IS A STORED VARIABLE
# HOWEVER, IF THE VARIABLE IS NOT TO BE 'EVALUATED', BUT RATHER IS TO BE CHANGED ON THE SPOT (SO NOT VAR1 + VAR2, BUT VAR1 + 1), THEN SIMPLE DOUBLE BRACKETS WILL DO
# IMPORTANT !!!!!!!!!!! BASH CANNOT DO FLOATING POINT ARETHMETIC, ONLY INTEGER ARETHMETIC, IN ORDER TO USE FLOATING POINT ARETHMETIC, USE 'bc' OR 'awk'
DURK=$((4.5/7)) # GIVES ERROR
DURK=$((4/7))
echo DURK
echo $DURK
(( DURK++ ))
(( DURK-=5 ))
DURK=$((DURK+5))
echo $DURK
# ONE CONFUSING POINT: IN '$(( ))', DO NOT USE '$' BEFORE ANY VARIABLES, AS WELL AS IN '(( ))'; ANOTHER CONFUSING POINT: {DURK=$((DURK + SOMETHING ))} == ((DURK += SOMETHING))
DURK=$(cat cat)
echo $DURK
# MODULO IS [NUMBER]%[MODULO NUMBER]:
DURK=$((7%6))
echo $DURK
# ANOTHER SYNTAX FOR (()) AND $(()) IS 'let [EXPRESSION TO BE EVALUATED]'
let DURK+=9
echo $DURK
# REMEMBER THAT [[ ]] IS USED FOR CONDITIONAL EXPRESSIONS RETURNING 0/1, (( )) IS USED FOR ARETHMETIC EXPRESSION, RETURNING ANY NUMBER OR STRING

# BASH DOES NOT CHANGE THE ORDER OF ARGUMENTS IN getopts:
echo ALL ARGUMENTS: $@
echo NUMBER OF ARGUMENTS: $#
echo FIRST ARGUMENT: $1

# NOTE THAT 'tar' ARCHIVES AND EXTRACTS ARCHIVES ON A SYSTEM, HOWEVER, THOSE ARCHIVES CAN BE COMPRESSED STILL, USING EITHER 'tar -z' OR 'gzip'
# THE USUAL EXTENSION FOR AN ARCHIVE IS '.tar', OF A COMPRESSION '.gz', OF A COMPRESSED ARCHIVE '.tar.gz' OR '.tgz'
# ARCHIVING AND COMPRESSING IS HANDY, BEING A SYSTEM ADMINISTRATOR, FOR ARCHIVING AND COMPRESSING USERS

# IMPORTANT TO NOTE: LOCKING ACCOUNTS IS RECOMMENDED WITH THE 'chage' COMMAND, NOT WITH 'passwd', SINCE 'chage' ALSO PREVENTS OTHERS TO LOG IN USING SSH, 'passwd' DOESN'T

# ORDER OF DECLARATION: SHEBANG, FILE IMPORTS, VARIABLE DECLARATIONS, FUNCTION DECLARATIONS AND GETTIN OPTIONS, SCRIPT
# IMPORTANT IS THAT THE EXIT STATUS OF A FUNCTION COULD IN MOST CASES BETTER BE INDICATED WITH 'return' SINCE 'exit' EXITS THE WHOLE SCRIPT, REGARDLESS OF WHETHER THERE IS MORE CODE TO BE EXECUTED
DURK=DURK
function MURK { if [[ $DURK == DURK ]]; then return 1; else return 0; fi; }
MURK
echo $?
function MURK { if [[ $DURK == DURK ]]; then exit 1; else exit 0; fi; }
MURK
echo $?


exit 0
