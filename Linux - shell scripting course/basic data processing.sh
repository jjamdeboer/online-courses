#!/bin/bash

# THE cut-COMMAND PRINTS SELECTED PARTS OF LINES TO STANDARD OUTPUT, CAN BE USED TO CUT OUT CERTAIN CHARACTERS OR TO DIVIDE THE TEXT BASED ON A DELIMITER
# IT IS VERY SIMILAR TO .split IN PYTHON, WITH A DEFAULT THAT IT SPLITS ON TABS, OTHER DELIMITERS SHOULD BE GIVEN AFTER THE FLAG -d
cut -d':' -f1,5-7 /etc/passwd | grep -i er | cat
# FOR A RANGE OF CHARACTERS, USE THE -c FLAG
cut -c 1-23 /etc/passwd | grep -i er | cat
# TO SPECIFY A RANGE [BEGIN]-[END] IS USED, WHEN 'BEGINNING' OR 'END' ARE NOT SPECIFIED, IT MEANS THAT COMMAND GOES FROM 'BEGINNING' TO THE END OF THE LINE, OR FROM THE START OF THE LINE TO 'END'
# TO HAVE MULTIPLE RANGES, SEPARATE THEM BY ','
cut -c 1,18- /etc/passwd | grep -i er | cat

# THE awk-COMMAND IS MORE POWERFUL, BUT ALSO WAY LESS INTUITIVE: IT ALLOWS FOR CHANGING THE ORDER OF THE FIELD AFTER THE DELIMITER IS APPLIED, ALLOWS FOR DELIMITERS WHICH ARE MORE THAN ONE CHARACTER LONG, ALLOWS FOR EXTRA STRINGS PRINTED BETWEEN THE FIELDS, BUT ALL AT THE COST OF UNDERSTANDABILITY AND READABILITY
awk -F ':' '{print "DURK: " $4, "MUUUUUUUUURK: " $1}' /etc/passwd | grep -i er
# USE awk INSTEAD OF cut IF THE DELIMITER CONSISTS OF MORE THAN A SINGLE CHARACTER OR IF IRREGULAR WHITESPACES ARE USED (TABS AND WHITESPACE ALTERNATED FOR EXAMPE), SINCE awk CONSIDERS ALL WHITESPACES EQUAL AND SO DELIMITS THAT SITUATION CORRECTLY

# FOR SORTING FILES ON CHARACTER OR NUMBER, USE sort
# FOR UNIQUE ENTRIES, SO NO REPETITION, USE sort -u; FOR NUMERICAL SORTING -n
cut -d':' -f1,5-7 /etc/passwd | grep -i x | sort | cat
du ../ -d1 | awk '{print $1, $2, $3, $4, $5, $6, $7, $8, $9, $10}' | sort -n | grep 1 | cat
# FOR FINDING THE NUMBER OF UNIQUE ENTRIES, USE 'uniq -c'
ls ../ | cut -d' ' -f 1 | uniq -c
# VERY SIMILAR TO nunique IN PANDAS

# DATA STREAMS IS THE FLOW OF DATA GOING THROUGH PIPES OR REDIRECTS OR FROM ONE SYSTEM TO ANOTHER
# ANOTHER WAY OF VIEWING THIS IS THAT STANDARD INPUT ~ STANDARD INPUT STREAM AND STANDARD OUTPUT ~ STANDARD OUTPUT STREAM AND STANDARD ERROR ~ STANDARD ERROR STREAM
# THERE EXISTS A STREAMING DATA EDITOR (SED) THAT CAN BE USED TO FILTER AND TRANSFORM STREAMED TEXT; IT DOES NOT WORK INTERACTIVELY, BUT MORE LIKE A SCRIPT
# STANDARDLY, sed DOES NOT CHANGE THE CONTENTS OF A FILE, BUT MERELY OPERATES ON IT (FOR EXAMPLE sed 's/[PATTER TO BE REPLACED]/[NEW PATTERN]/[FLAGS]' [FILE TO REPLACE PATTERN IN])
# sed CAN BE THOUGHT OF AS EXECUTING A LINE COMMAND IN VIM WITHOUT ACTUALLY OPENING VIM
# FLAGS CAN BE 'i' OR 'I' FOR CASE INSENSITIVE, OR 'g' FOR ALTERING ALL THE INSTANCES IN ALL THE LINES
# THERE CAN ALSO BE FLAGS GIVEN TO sed ITSELF, AMONG OTHERS 'i' OR 'i[BACKUP EXTENSION]', WHICH REPLACES THE CONTENTS OF THE ORIGINAL FILE (AND OPTIONALLY STORES THE ORIGINAL FILE IN A BACKUP FILE WITH THE EXTENSION 'BACKUP EXTENSION')
# sed IS MOST OFTEN USED IN PIPES IN THE COMMAND LINE OR SCRIPTS; MOSTLY USED FOR FIND OR REPLACE OR DELETE SOME TEXT
grep -i deb /etc/passwd | sort | sed 's#:#REPLACED WORD HERE#gi'
grep -i y /etc/passwd | sort | sed '/4/d'
# sed CAN ALSO BE APPLIED TO SCRIPTS, WHICH CAN HAVE .sh- OR .sed-EXTENSION, SO THAT IT RUNS THE COMMANDS IN THOSE SCRIPTS
